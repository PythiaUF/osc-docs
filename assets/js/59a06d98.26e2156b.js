"use strict";(self.webpackChunkosc_docs=self.webpackChunkosc_docs||[]).push([[5031],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>g});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=p(a),c=r,g=d["".concat(l,".").concat(c)]||d[c]||u[c]||i;return a?n.createElement(g,s(s({ref:t},m),{},{components:a})):n.createElement(g,s({ref:t},m))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=c;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},4035:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={title:"Image Storage",description:"Club Website Developer Database",sidebar_position:3},s="Image Storage",o={unversionedId:"Developers/Databases/image-storage",id:"Developers/Databases/image-storage",title:"Image Storage",description:"Club Website Developer Database",source:"@site/docs/website/Developers/Databases/image-storage.md",sourceDirName:"Developers/Databases",slug:"/Developers/Databases/image-storage",permalink:"/docs/website/Developers/Databases/image-storage",draft:!1,editUrl:"https://github.com/ufosc/osc-docs/blob/main/docs/website/Developers/Databases/image-storage.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Image Storage",description:"Club Website Developer Database",sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Database Models",permalink:"/docs/website/Developers/Databases/models"},next:{title:"API & Routes",permalink:"/docs/website/Developers/API/"}},l={},p=[{value:"Express Multer",id:"express-multer",level:2},{value:"Image Upload Route",id:"image-upload-route",level:2}],m={toc:p},d="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"image-storage"},"Image Storage"),(0,r.kt)("p",null,"The images API route exists to serve image content for blog articles. To minimise latency, images are stored on the server's hard disk, whilst image metadata lives on the database. The purpose of the metadata is to assert the image's existence, physical location, description, and API path."),(0,r.kt)("p",null,"If you'd like to learn more about the type of metadata that's stored, refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ufosc/Club_Website_2/blob/main/model/images.js"},"models/images.js"),"."),(0,r.kt)("h2",{id:"express-multer"},"Express Multer"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://expressjs.com/en/resources/middleware/multer.html"},"Express Multer")," library enables the Express webserver to do multiplexing. Consequently, this means that it can receive multiform and multipart data (data that takes multiple requests to transmit, i.e large image files). The library is configured to save incoming image files to the disk (",(0,r.kt)("inlineCode",{parentName:"p"},"/uploads"),") folder:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="routes/images.js"',title:'"routes/images.js"'},"const multer = require('multer')\n// ...\n\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    // Create directory if it doesnt exist.\n    if (!fs.existsSync('uploads/')) {\n      fs.mkdirSync('uploads/', { recursive: true })\n    }\n    cb(null, 'uploads/')\n  },\n  filename: (req, file, cb) => {\n    // If its not a .jpeg, then it will be caught later.\n    const suffix = (file.mimetype === 'image/png') ? '.png' : '.jpeg'\n    const prefix = Date.now() + '-' + Math.round(Math.random() * 1E9)\n    cb(null, prefix + suffix)\n  }\n})\n// ...\n\n// Max size: 25MB\nconst upload = multer({ storage, limits: { fileSize: 26214400 } })\n")),(0,r.kt)("p",null,"Essentially, whenever a new file arrives, it will be stored in the destination specified by ",(0,r.kt)("inlineCode",{parentName:"p"},"storage.destination")," with the file name specified by ",(0,r.kt)("inlineCode",{parentName:"p"},"storage.filename"),". The file name function (",(0,r.kt)("inlineCode",{parentName:"p"},"storage.filename"),") generates a file name according to the following criteria:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If the file type is '.png', then the file name suffix will be ",(0,r.kt)("inlineCode",{parentName:"li"},".png"),". Otherwise, it will be ",(0,r.kt)("inlineCode",{parentName:"li"},".jpeg"),". If it is neither, an error will be issued later on ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/ufosc/Club_Website_2/blob/main/routes/images.js#L65"},"here"),"."),(0,r.kt)("li",{parentName:"ol"},"The prefix will be the current date, plus a dash symbol ('-'), plus some random number."),(0,r.kt)("li",{parentName:"ol"},"Finally, the file name is produced by combining the two strings: ",(0,r.kt)("inlineCode",{parentName:"li"},"prefix + suffix"),".")),(0,r.kt)("p",null,"With the multer storage configured, the ",(0,r.kt)("inlineCode",{parentName:"p"},"storage")," constant is passed along with a ",(0,r.kt)("inlineCode",{parentName:"p"},"fileSize")," limit (set to 25MB) to produce the ",(0,r.kt)("inlineCode",{parentName:"p"},"upload")," constant, which can now be used as an ",(0,r.kt)("a",{parentName:"p",href:"https://expressjs.com/en/guide/using-middleware.html"},"Express Middleware"),"."),(0,r.kt)("admonition",{title:"Express Middleware",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application\u2019s request-response cycle. They control the data coming and going from the server's routes. When the upload ",(0,r.kt)("inlineCode",{parentName:"p"},"upload.single('file')")," is used, the middleware will ensure that a single file has been sent by the client, and will then store it on the disk.")),(0,r.kt)("h2",{id:"image-upload-route"},"Image Upload Route"),(0,r.kt)("p",null,"Image API operations are managed in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ufosc/Club_Website_2/blob/main/routes/images.js"},"routes/images.js"),". An excerpt of the image upload route is copied below as an explanatory reference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="routes/images.js"',title:'"routes/images.js"'},"router.post('/', passport.authenticate('loggedIn', { session: false }), upload.single('File'), (req, res) => {\n\n  // ...\n\n  const image = new ImageModel({\n    filename: req.file.filename,\n    description: req.body.Description,\n    path: req.file.path\n  })\n\n  image.save((err) => {\n    if (err) return res.status(500).send({ error: 'Internal Server Error' })\n  })\n\n  return res.status(200).send(image)\n})\n")),(0,r.kt)("p",null,"First, the ",(0,r.kt)("inlineCode",{parentName:"p"},"passport.authenticate('loggedIn', { session: false })")," ensures that the user is ",(0,r.kt)("inlineCode",{parentName:"p"},"loggedIn")," before they can proceed with uploading an image. Next, ",(0,r.kt)("inlineCode",{parentName:"p"},"upload.single('File')")," ensures that a single file has been sent, and then saves that file on the disk. Finally, ",(0,r.kt)("inlineCode",{parentName:"p"},"(req, res)")," is the function definition that handles the rest of the image upload routine."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"upload")," middleware will automatically store the file's metadata in the ",(0,r.kt)("inlineCode",{parentName:"p"},"req")," object, that way we can pass it along to our ",(0,r.kt)("inlineCode",{parentName:"p"},"(req, res)")," function:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"req.file.filename")," stores the name of the file, as defined by ",(0,r.kt)("inlineCode",{parentName:"li"},"storage.filename"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"req.file.path")," is the file system path where our file is located."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"req.body.Description")," is not actually handled by ",(0,r.kt)("inlineCode",{parentName:"li"},"upload"),". It is passed by the image submission form and keeps the user-specified image description.")),(0,r.kt)("p",null,"With this information, we create a new ImageModel instance (read ",(0,r.kt)("a",{parentName:"p",href:"/docs/website/Developers/Databases/mongodb"},"Using MongoDB")," to learn more about models):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const image = new ImageModel({\n    filename: req.file.filename,\n    description: req.body.Description,\n    path: req.file.path\n})\n")),(0,r.kt)("p",null,"And save it to the database:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"image.save((err) => {\n    if (err) return res.status(500).send({ error: 'Internal Server Error' })\n})\n")),(0,r.kt)("p",null,"Note that the physical image has already been saved by ",(0,r.kt)("inlineCode",{parentName:"p"},"upload")," to our server's ",(0,r.kt)("inlineCode",{parentName:"p"},"/upload")," folder."),(0,r.kt)("p",null,"Henceforth, whenever we want to retrieve and send an image (assuming we know it's ID), we can query the MongoDB database, retrieve its file system path, and load the image into memory:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="routes/images.js"',title:'"routes/images.js"'},"const imageExists = await ImageModel.findById(req.params.id)\nif (!imageExists) {\n    return res.status(404).send({ error: 'ID does not exist' })\n}\n\nres.status(200).sendFile(resolve(imageExists.path))\n")),(0,r.kt)("p",null,"If we find that, for some reason, the file no longer exists on the file system, we delete it from the database and return an error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="routes/images.js"',title:'"routes/images.js"'},"if (!fs.existsSync(imageExists.path)) {\n    await ImageModel.findByIdAndDelete(req.params.id)\n    return res.status(404).send({ error: 'image does not exist' })\n}\n")))}u.isMDXComponent=!0}}]);